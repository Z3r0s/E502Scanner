"""
Vulnerability Assessment Module for E502 OSINT Terminal
Provides comprehensive vulnerability scanning capabilities including
common vulnerability detection, security header analysis, and service enumeration.
"""

import requests
import socket
import ssl
import nmap
from typing import Dict, List, Optional, Tuple
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
import json
from datetime import datetime
import re
import urllib3
from bs4 import BeautifulSoup
import concurrent.futures
import asyncio
import aiohttp
from urllib.parse import urlparse, urljoin

urllib3.disable_warnings()
console = Console()

class VulnerabilityScanner:
    def __init__(self):
        self.nm = nmap.PortScanner()
        self.session = requests.Session()
        self.session.verify = False
        self.common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 993, 995, 3306, 3389, 5432, 8080]
        self.vulnerability_patterns = {
            'sql_injection': [
                r"sql syntax.*mysql",
                r"warning.*mysql_.*",
                r"valid mysql result",
                r"check the manual that corresponds to your (mysql|mariadb) server version",
                r"mysql_fetch_array",
                r"mysql_num_rows",
                r"mysql_fetch_assoc",
                r"mysql_fetch_row",
                r"mysql_connect",
                r"mysql_query",
                r"mysql_error",
                r"mysql_result",
                r"mysql_close",
                r"mysql_select_db",
                r"mysql_affected_rows",
                r"mysql_get_client_info",
                r"mysql_get_host_info",
                r"mysql_get_proto_info",
                r"mysql_get_server_info",
                r"mysql_info",
                r"mysql_insert_id",
                r"mysql_list_dbs",
                r"mysql_list_fields",
                r"mysql_list_tables",
                r"mysql_num_fields",
                r"mysql_pconnect",
                r"mysql_ping",
                r"mysql_real_escape_string",
                r"mysql_stat",
                r"mysql_thread_id",
                r"mysql_unbuffered_query"
            ],
            'xss': [
                r"<script>.*?</script>",
                r"javascript:",
                r"onerror=",
                r"onload=",
                r"onmouseover=",
                r"onmouseout=",
                r"onmousedown=",
                r"onmouseup=",
                r"onclick=",
                r"ondblclick=",
                r"onkeydown=",
                r"onkeypress=",
                r"onkeyup=",
                r"onsubmit=",
                r"onreset=",
                r"onselect=",
                r"onchange=",
                r"onfocus=",
                r"onblur="
            ],
            'path_traversal': [
                r"\.\.\/",
                r"\.\.\\",
                r"\.\.\/\.\.\/",
                r"\.\.\\\.\.\\",
                r"\.\.\/\.\.\/\.\.\/",
                r"\.\.\\\.\.\\\.\.\\"
            ],
            'csrf': [
                r"csrf_token",
                r"xsrf_token",
                r"csrf-token",
                r"xsrf-token",
                r"csrf",
                r"xsrf"
            ],
            'ssrf': [
                r"127\.0\.0\.1",
                r"localhost",
                r"0\.0\.0\.0",
                r"::1",
                r"file://",
                r"gopher://",
                r"dict://",
                r"ldap://",
                r"tftp://",
                r"ftp://"
            ],
            'xxe': [
                r"<!ENTITY",
                r"<!DOCTYPE",
                r"<!ELEMENT",
                r"<!ATTLIST",
                r"<!NOTATION",
                r"<!ENTITY %",
                r"<!ENTITY &",
                r"<!ENTITY #"
            ],
            'rce': [
                r"exec\(",
                r"eval\(",
                r"system\(",
                r"shell_exec\(",
                r"passthru\(",
                r"popen\(",
                r"proc_open\(",
                r"pcntl_exec\(",
                r"assert\(",
                r"preg_replace\(",
                r"create_function\(",
                r"call_user_func\(",
                r"call_user_func_array\(",
                r"array_map\(",
                r"array_filter\(",
                r"array_walk\(",
                r"array_reduce\(",
                r"uasort\(",
                r"uksort\(",
                r"usort\("
            ]
        }
        
        self.severity_levels = {
            'critical': 4,
            'high': 3,
            'medium': 2,
            'low': 1,
            'info': 0
        }
        
        self.remediation_guidelines = {
            'sql_injection': "Use parameterized queries or prepared statements. Implement input validation and sanitization.",
            'xss': "Implement Content Security Policy (CSP). Use output encoding and input validation.",
            'path_traversal': "Implement proper path validation and sanitization. Use chroot jails where possible.",
            'csrf': "Implement CSRF tokens and validate them on all state-changing requests.",
            'ssrf': "Implement proper URL validation and whitelist allowed protocols and hosts.",
            'xxe': "Disable XML external entity processing. Use secure XML parsers.",
            'rce': "Implement proper input validation and sanitization. Use safe alternatives to dangerous functions."
        }

    def scan_target(self, target: str) -> Dict:
        """Perform comprehensive vulnerability scan of target."""
        try:
            scan_results = {
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'open_ports': self._scan_ports(target),
                'services': self._enumerate_services(target),
                'security_headers': self._analyze_security_headers(target),
                'vulnerabilities': self._check_vulnerabilities(target),
                'default_credentials': self._check_default_credentials(target),
                'api_endpoints': self._discover_api_endpoints(target),
                'graphql_analysis': self._analyze_graphql(target),
                'websocket_security': self._check_websocket_security(target),
                'risk_assessment': self._assess_risk(target)
            }
            
            return scan_results
        except Exception as e:
            console.print(f"[red]Error during vulnerability scan: {str(e)}[/]")
            return {}

    def _scan_ports(self, target: str) -> List[Dict]:
        """Scan for open ports."""
        try:
            self.nm.scan(target, arguments='-sS -sV -p-')
            open_ports = []
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    ports = self.nm[host][proto].keys()
                    for port in ports:
                        service = self.nm[host][proto][port]
                        open_ports.append({
                            'port': port,
                            'protocol': proto,
                            'state': service.get('state', ''),
                            'name': service.get('name', ''),
                            'product': service.get('product', ''),
                            'version': service.get('version', '')
                        })
            
            return open_ports
        except Exception as e:
            console.print(f"[red]Error scanning ports: {str(e)}[/]")
            return []

    def _enumerate_services(self, target: str) -> Dict:
        """Enumerate services running on target."""
        try:
            services = {}
            
            # HTTP/HTTPS
            for port in [80, 443, 8080]:
                try:
                    protocol = 'https' if port == 443 else 'http'
                    url = f"{protocol}://{target}:{port}"
                    response = self.session.get(url, timeout=5)
                    if response.status_code < 400:
                        services[f"{protocol}_{port}"] = {
                            'status': 'running',
                            'server': response.headers.get('Server', ''),
                            'technologies': self._detect_technologies(response.text),
                            'headers': dict(response.headers)
                        }
                except:
                    continue
            
            # SSH
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((target, 22))
                if result == 0:
                    services['ssh'] = {'status': 'running'}
                sock.close()
            except:
                pass
            
            # FTP
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((target, 21))
                if result == 0:
                    services['ftp'] = {'status': 'running'}
                sock.close()
            except:
                pass
            
            return services
        except Exception as e:
            console.print(f"[red]Error enumerating services: {str(e)}[/]")
            return {}

    def _analyze_security_headers(self, target: str) -> Dict:
        """Analyze security headers."""
        try:
            headers = {}
            for port in [80, 443, 8080]:
                try:
                    protocol = 'https' if port == 443 else 'http'
                    url = f"{protocol}://{target}:{port}"
                    response = self.session.get(url, timeout=5)
                    
                    security_headers = {
                        'Strict-Transport-Security': response.headers.get('Strict-Transport-Security', ''),
                        'X-Frame-Options': response.headers.get('X-Frame-Options', ''),
                        'X-Content-Type-Options': response.headers.get('X-Content-Type-Options', ''),
                        'X-XSS-Protection': response.headers.get('X-XSS-Protection', ''),
                        'Content-Security-Policy': response.headers.get('Content-Security-Policy', ''),
                        'Referrer-Policy': response.headers.get('Referrer-Policy', ''),
                        'Permissions-Policy': response.headers.get('Permissions-Policy', '')
                    }
                    
                    headers[f"{protocol}_{port}"] = security_headers
                except:
                    continue
            
            return headers
        except Exception as e:
            console.print(f"[red]Error analyzing security headers: {str(e)}[/]")
            return {}

    def _check_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for common vulnerabilities."""
        vulnerabilities = []
        
        # Check for open ports with known vulnerabilities
        for port in self._scan_ports(target):
            if port['name'] in ['http', 'https']:
                # Check for common web vulnerabilities
                web_vulns = self._check_web_vulnerabilities(target, port['port'])
                vulnerabilities.extend(web_vulns)
            elif port['name'] in ['ssh', 'ftp', 'telnet']:
                # Check for weak protocols
                vulnerabilities.append({
                    'type': 'weak_protocol',
                    'port': port['port'],
                    'protocol': port['name'],
                    'severity': 'high',
                    'description': f"Unencrypted {port['name']} service detected"
                })
        
        return vulnerabilities

    def _check_web_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Check for web vulnerabilities."""
        vulnerabilities = []
        
        try:
            protocol = 'https' if port == 443 else 'http'
            url = f"{protocol}://{target}:{port}"
            
            # Check for SQL injection
            sql_payloads = ["'", "1' OR '1'='1", "1; DROP TABLE users"]
            for payload in sql_payloads:
                try:
                    response = self.session.get(f"{url}/?id={payload}", timeout=5)
                    for pattern in self.vulnerability_patterns['sql_injection']:
                        if re.search(pattern, response.text, re.I):
                            vulnerabilities.append({
                                'type': 'sql_injection',
                                'url': url,
                                'payload': payload,
                                'severity': 'high',
                                'description': 'Potential SQL injection vulnerability detected'
                            })
                            break
                except:
                    continue
            
            # Check for XSS
            xss_payloads = [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "javascript:alert(1)"
            ]
            for payload in xss_payloads:
                try:
                    response = self.session.get(f"{url}/?q={payload}", timeout=5)
                    for pattern in self.vulnerability_patterns['xss']:
                        if re.search(pattern, response.text, re.I):
                            vulnerabilities.append({
                                'type': 'xss',
                                'url': url,
                                'payload': payload,
                                'severity': 'medium',
                                'description': 'Potential XSS vulnerability detected'
                            })
                            break
                except:
                    continue
            
            # Check for path traversal
            path_payloads = [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\win.ini"
            ]
            for payload in path_payloads:
                try:
                    response = self.session.get(f"{url}/?file={payload}", timeout=5)
                    for pattern in self.vulnerability_patterns['path_traversal']:
                        if re.search(pattern, response.text, re.I):
                            vulnerabilities.append({
                                'type': 'path_traversal',
                                'url': url,
                                'payload': payload,
                                'severity': 'high',
                                'description': 'Potential path traversal vulnerability detected'
                            })
                            break
                except:
                    continue
            
        except Exception as e:
            console.print(f"[red]Error checking web vulnerabilities: {str(e)}[/]")
        
        return vulnerabilities

    def _check_default_credentials(self, target: str) -> List[Dict]:
        """Check for default credentials."""
        default_creds = {
            'ftp': [('anonymous', 'anonymous')],
            'ssh': [('root', 'root'), ('admin', 'admin')],
            'mysql': [('root', ''), ('admin', 'admin')],
            'postgresql': [('postgres', 'postgres')],
            'tomcat': [('tomcat', 'tomcat'), ('admin', 'admin')]
        }
        
        results = []
        
        for service, credentials in default_creds.items():
            if service == 'ftp':
                try:
                    import ftplib
                    ftp = ftplib.FTP(target)
                    for username, password in credentials:
                        try:
                            ftp.login(username, password)
                            results.append({
                                'service': 'ftp',
                                'username': username,
                                'password': password,
                                'status': 'success'
                            })
                            break
                        except:
                            continue
                except:
                    pass
            
            elif service == 'ssh':
                try:
                    import paramiko
                    for username, password in credentials:
                        try:
                            ssh = paramiko.SSHClient()
                            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                            ssh.connect(target, username=username, password=password, timeout=5)
                            results.append({
                                'service': 'ssh',
                                'username': username,
                                'password': password,
                                'status': 'success'
                            })
                            break
                        except:
                            continue
                except:
                    pass
        
        return results

    def _detect_technologies(self, html: str) -> List[str]:
        """Detect technologies used in web application."""
        technologies = []
        
        # Common technology signatures
        tech_patterns = {
            'PHP': r'\.php|X-Powered-By: PHP',
            'ASP.NET': r'\.aspx|X-AspNet-Version',
            'Java': r'\.jsp|X-Powered-By: Java',
            'Python': r'\.py|X-Powered-By: Python',
            'Ruby': r'\.rb|X-Powered-By: Ruby',
            'WordPress': r'wp-content|wp-includes',
            'Drupal': r'drupal|Drupal.settings',
            'Joomla': r'joomla|com_content',
            'jQuery': r'jquery\.js',
            'Bootstrap': r'bootstrap\.css|bootstrap\.js',
            'Angular': r'angular\.js|ng-',
            'React': r'react\.js|react-dom',
            'Vue': r'vue\.js|v-'
        }
        
        for tech, pattern in tech_patterns.items():
            if re.search(pattern, html, re.I):
                technologies.append(tech)
        
        return technologies

    def display_scan_results(self, results: Dict) -> None:
        """Display vulnerability scan results."""
        table = Table(title="Vulnerability Scan Results")
        table.add_column("Category", style="cyan")
        table.add_column("Details", style="green")
        
        for key, value in results.items():
            if isinstance(value, (dict, list)):
                value = json.dumps(value, indent=2)
            table.add_row(str(key), str(value))
        
        console.print(table)

    def _discover_api_endpoints(self, target: str) -> List[Dict]:
        """Discover and analyze API endpoints."""
        try:
            endpoints = []
            common_paths = [
                '/api', '/api/v1', '/api/v2', '/api/v3',
                '/rest', '/graphql', '/swagger', '/openapi',
                '/docs', '/documentation', '/api-docs'
            ]
            
            for path in common_paths:
                try:
                    url = f"https://{target}{path}"
                    response = self.session.get(url, timeout=5)
                    if response.status_code < 400:
                        endpoints.append({
                            'path': path,
                            'status_code': response.status_code,
                            'content_type': response.headers.get('Content-Type', ''),
                            'methods': self._check_http_methods(url),
                            'authentication': self._check_auth_requirements(url)
                        })
                except:
                    continue
            
            return endpoints
        except Exception as e:
            console.print(f"[red]Error discovering API endpoints: {str(e)}[/]")
            return []

    def _analyze_graphql(self, target: str) -> Dict:
        """Analyze GraphQL endpoint if present."""
        try:
            graphql_paths = ['/graphql', '/graphiql', '/graphql/console']
            for path in graphql_paths:
                try:
                    url = f"https://{target}{path}"
                    response = self.session.post(url, json={'query': '{ __schema { types { name } } }'}, timeout=5)
                    if response.status_code < 400:
                        return {
                            'endpoint': path,
                            'introspection_enabled': True,
                            'schema': response.json(),
                            'security_issues': self._check_graphql_security(url)
                        }
                except:
                    continue
            return {'endpoint': None, 'introspection_enabled': False}
        except Exception as e:
            console.print(f"[red]Error analyzing GraphQL: {str(e)}[/]")
            return {'endpoint': None, 'introspection_enabled': False}

    def _check_websocket_security(self, target: str) -> Dict:
        """Check WebSocket security."""
        try:
            ws_url = f"wss://{target}/ws"
            security_issues = []
            
            # Check for WSS (secure WebSocket)
            if not ws_url.startswith('wss://'):
                security_issues.append('WebSocket not using WSS (secure)')
            
            # Check for authentication
            if not self._check_ws_auth(ws_url):
                security_issues.append('WebSocket lacks authentication')
            
            # Check for origin validation
            if not self._check_ws_origin(ws_url):
                security_issues.append('WebSocket lacks origin validation')
            
            return {
                'endpoint': ws_url,
                'security_issues': security_issues,
                'recommendations': self._get_ws_recommendations(security_issues)
            }
        except Exception as e:
            console.print(f"[red]Error checking WebSocket security: {str(e)}[/]")
            return {'endpoint': None, 'security_issues': []}

    def _assess_risk(self, target: str) -> Dict:
        """Assess overall risk level of target."""
        try:
            vulnerabilities = self._check_vulnerabilities(target)
            risk_score = 0
            risk_factors = []
            
            for vuln in vulnerabilities:
                severity = vuln.get('severity', 'low')
                risk_score += self.severity_levels.get(severity, 0)
                risk_factors.append({
                    'type': vuln.get('type', 'unknown'),
                    'severity': severity,
                    'description': vuln.get('description', '')
                })
            
            risk_level = 'low'
            if risk_score >= 10:
                risk_level = 'critical'
            elif risk_score >= 7:
                risk_level = 'high'
            elif risk_score >= 4:
                risk_level = 'medium'
            
            return {
                'risk_score': risk_score,
                'risk_level': risk_level,
                'risk_factors': risk_factors,
                'recommendations': self._get_risk_recommendations(risk_factors)
            }
        except Exception as e:
            console.print(f"[red]Error assessing risk: {str(e)}[/]")
            return {'risk_level': 'unknown', 'risk_score': 0}

    def _get_risk_recommendations(self, risk_factors: List[Dict]) -> List[str]:
        """Get recommendations based on risk factors."""
        recommendations = []
        for factor in risk_factors:
            vuln_type = factor.get('type', '')
            if vuln_type in self.remediation_guidelines:
                recommendations.append(self.remediation_guidelines[vuln_type])
        return list(set(recommendations))

    def _check_http_methods(self, url: str) -> List[str]:
        """Check supported HTTP methods."""
        methods = []
        for method in ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']:
            try:
                response = self.session.request(method, url, timeout=5)
                if response.status_code < 400:
                    methods.append(method)
            except:
                continue
        return methods

    def _check_auth_requirements(self, url: str) -> Dict:
        """Check authentication requirements."""
        try:
            response = self.session.get(url, timeout=5)
            auth_required = response.status_code == 401
            auth_type = response.headers.get('WWW-Authenticate', '')
            return {
                'required': auth_required,
                'type': auth_type,
                'headers': dict(response.headers)
            }
        except:
            return {'required': False, 'type': None}

    def _check_graphql_security(self, url: str) -> List[str]:
        """Check GraphQL security issues."""
        security_issues = []
        
        # Check for introspection
        try:
            response = self.session.post(url, json={'query': '{ __schema { types { name } } }'}, timeout=5)
            if response.status_code < 400:
                security_issues.append('GraphQL introspection enabled')
        except:
            pass
        
        # Check for batch queries
        try:
            response = self.session.post(url, json=[{'query': '{ __schema { types { name } } }'}], timeout=5)
            if response.status_code < 400:
                security_issues.append('GraphQL batch queries enabled')
        except:
            pass
        
        return security_issues

    def _check_ws_auth(self, ws_url: str) -> bool:
        """Check WebSocket authentication."""
        try:
            response = self.session.get(ws_url.replace('wss://', 'https://'), timeout=5)
            return response.status_code == 401
        except:
            return False

    def _check_ws_origin(self, ws_url: str) -> bool:
        """Check WebSocket origin validation."""
        try:
            headers = {'Origin': 'https://malicious-site.com'}
            response = self.session.get(ws_url.replace('wss://', 'https://'), headers=headers, timeout=5)
            return response.status_code == 403
        except:
            return False

    def _get_ws_recommendations(self, security_issues: List[str]) -> List[str]:
        """Get WebSocket security recommendations."""
        recommendations = []
        if 'WebSocket not using WSS (secure)' in security_issues:
            recommendations.append('Use WSS (secure WebSocket) instead of WS')
        if 'WebSocket lacks authentication' in security_issues:
            recommendations.append('Implement proper authentication for WebSocket connections')
        if 'WebSocket lacks origin validation' in security_issues:
            recommendations.append('Implement origin validation for WebSocket connections')
        return recommendations 
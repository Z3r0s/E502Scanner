"""
Vulnerability Assessment Module for E502 OSINT Terminal
Provides comprehensive vulnerability scanning capabilities including
common vulnerability detection, security header analysis, and service enumeration.
"""

import requests
import socket
import ssl
import nmap
from typing import Dict, List, Optional, Tuple
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
import json
from datetime import datetime
import re
import urllib3
from bs4 import BeautifulSoup
import concurrent.futures
import asyncio
import aiohttp
from urllib.parse import urlparse, urljoin

urllib3.disable_warnings()
console = Console()

class VulnerabilityScanner:
    def __init__(self):
        self.nm = nmap.PortScanner()
        self.session = requests.Session()
        self.session.verify = False
        self.common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 445, 993, 995, 3306, 3389, 5432, 8080]
        self.vulnerability_patterns = {
            'sql_injection': [
                r"sql syntax.*mysql",
                r"warning.*mysql_.*",
                r"valid mysql result",
                r"check the manual that corresponds to your (mysql|mariadb) server version",
                r"mysql_fetch_array",
                r"mysql_num_rows",
                r"mysql_fetch_assoc",
                r"mysql_fetch_row",
                r"mysql_connect",
                r"mysql_query",
                r"mysql_error",
                r"mysql_result",
                r"mysql_close",
                r"mysql_select_db",
                r"mysql_affected_rows",
                r"mysql_get_client_info",
                r"mysql_get_host_info",
                r"mysql_get_proto_info",
                r"mysql_get_server_info",
                r"mysql_info",
                r"mysql_insert_id",
                r"mysql_list_dbs",
                r"mysql_list_fields",
                r"mysql_list_tables",
                r"mysql_num_fields",
                r"mysql_pconnect",
                r"mysql_ping",
                r"mysql_real_escape_string",
                r"mysql_stat",
                r"mysql_thread_id",
                r"mysql_unbuffered_query"
            ],
            'xss': [
                r"<script>.*?</script>",
                r"javascript:",
                r"onerror=",
                r"onload=",
                r"onmouseover=",
                r"onmouseout=",
                r"onmousedown=",
                r"onmouseup=",
                r"onclick=",
                r"ondblclick=",
                r"onkeydown=",
                r"onkeypress=",
                r"onkeyup=",
                r"onsubmit=",
                r"onreset=",
                r"onselect=",
                r"onchange=",
                r"onfocus=",
                r"onblur="
            ],
            'path_traversal': [
                r"\.\.\/",
                r"\.\.\\",
                r"\.\.\/\.\.\/",
                r"\.\.\\\.\.\\",
                r"\.\.\/\.\.\/\.\.\/",
                r"\.\.\\\.\.\\\.\.\\"
            ]
        }

    def scan_target(self, target: str) -> Dict:
        """Perform comprehensive vulnerability scan of target."""
        try:
            scan_results = {
                'target': target,
                'timestamp': datetime.now().isoformat(),
                'open_ports': self._scan_ports(target),
                'services': self._enumerate_services(target),
                'security_headers': self._analyze_security_headers(target),
                'vulnerabilities': self._check_vulnerabilities(target),
                'default_credentials': self._check_default_credentials(target)
            }
            
            return scan_results
        except Exception as e:
            console.print(f"[red]Error during vulnerability scan: {str(e)}[/]")
            return {}

    def _scan_ports(self, target: str) -> List[Dict]:
        """Scan for open ports."""
        try:
            self.nm.scan(target, arguments='-sS -sV -p-')
            open_ports = []
            
            for host in self.nm.all_hosts():
                for proto in self.nm[host].all_protocols():
                    ports = self.nm[host][proto].keys()
                    for port in ports:
                        service = self.nm[host][proto][port]
                        open_ports.append({
                            'port': port,
                            'protocol': proto,
                            'state': service.get('state', ''),
                            'name': service.get('name', ''),
                            'product': service.get('product', ''),
                            'version': service.get('version', '')
                        })
            
            return open_ports
        except Exception as e:
            console.print(f"[red]Error scanning ports: {str(e)}[/]")
            return []

    def _enumerate_services(self, target: str) -> Dict:
        """Enumerate services running on target."""
        try:
            services = {}
            
            # HTTP/HTTPS
            for port in [80, 443, 8080]:
                try:
                    protocol = 'https' if port == 443 else 'http'
                    url = f"{protocol}://{target}:{port}"
                    response = self.session.get(url, timeout=5)
                    if response.status_code < 400:
                        services[f"{protocol}_{port}"] = {
                            'status': 'running',
                            'server': response.headers.get('Server', ''),
                            'technologies': self._detect_technologies(response.text),
                            'headers': dict(response.headers)
                        }
                except:
                    continue
            
            # SSH
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((target, 22))
                if result == 0:
                    services['ssh'] = {'status': 'running'}
                sock.close()
            except:
                pass
            
            # FTP
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                result = sock.connect_ex((target, 21))
                if result == 0:
                    services['ftp'] = {'status': 'running'}
                sock.close()
            except:
                pass
            
            return services
        except Exception as e:
            console.print(f"[red]Error enumerating services: {str(e)}[/]")
            return {}

    def _analyze_security_headers(self, target: str) -> Dict:
        """Analyze security headers."""
        try:
            headers = {}
            for port in [80, 443, 8080]:
                try:
                    protocol = 'https' if port == 443 else 'http'
                    url = f"{protocol}://{target}:{port}"
                    response = self.session.get(url, timeout=5)
                    
                    security_headers = {
                        'Strict-Transport-Security': response.headers.get('Strict-Transport-Security', ''),
                        'X-Frame-Options': response.headers.get('X-Frame-Options', ''),
                        'X-Content-Type-Options': response.headers.get('X-Content-Type-Options', ''),
                        'X-XSS-Protection': response.headers.get('X-XSS-Protection', ''),
                        'Content-Security-Policy': response.headers.get('Content-Security-Policy', ''),
                        'Referrer-Policy': response.headers.get('Referrer-Policy', ''),
                        'Permissions-Policy': response.headers.get('Permissions-Policy', '')
                    }
                    
                    headers[f"{protocol}_{port}"] = security_headers
                except:
                    continue
            
            return headers
        except Exception as e:
            console.print(f"[red]Error analyzing security headers: {str(e)}[/]")
            return {}

    def _check_vulnerabilities(self, target: str) -> List[Dict]:
        """Check for common vulnerabilities."""
        vulnerabilities = []
        
        # Check for open ports with known vulnerabilities
        for port in self._scan_ports(target):
            if port['name'] in ['http', 'https']:
                # Check for common web vulnerabilities
                web_vulns = self._check_web_vulnerabilities(target, port['port'])
                vulnerabilities.extend(web_vulns)
            elif port['name'] in ['ssh', 'ftp', 'telnet']:
                # Check for weak protocols
                vulnerabilities.append({
                    'type': 'weak_protocol',
                    'port': port['port'],
                    'protocol': port['name'],
                    'severity': 'high',
                    'description': f"Unencrypted {port['name']} service detected"
                })
        
        return vulnerabilities

    def _check_web_vulnerabilities(self, target: str, port: int) -> List[Dict]:
        """Check for web vulnerabilities."""
        vulnerabilities = []
        
        try:
            protocol = 'https' if port == 443 else 'http'
            url = f"{protocol}://{target}:{port}"
            
            # Check for SQL injection
            sql_payloads = ["'", "1' OR '1'='1", "1; DROP TABLE users"]
            for payload in sql_payloads:
                try:
                    response = self.session.get(f"{url}/?id={payload}", timeout=5)
                    for pattern in self.vulnerability_patterns['sql_injection']:
                        if re.search(pattern, response.text, re.I):
                            vulnerabilities.append({
                                'type': 'sql_injection',
                                'url': url,
                                'payload': payload,
                                'severity': 'high',
                                'description': 'Potential SQL injection vulnerability detected'
                            })
                            break
                except:
                    continue
            
            # Check for XSS
            xss_payloads = [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "javascript:alert(1)"
            ]
            for payload in xss_payloads:
                try:
                    response = self.session.get(f"{url}/?q={payload}", timeout=5)
                    for pattern in self.vulnerability_patterns['xss']:
                        if re.search(pattern, response.text, re.I):
                            vulnerabilities.append({
                                'type': 'xss',
                                'url': url,
                                'payload': payload,
                                'severity': 'medium',
                                'description': 'Potential XSS vulnerability detected'
                            })
                            break
                except:
                    continue
            
            # Check for path traversal
            path_payloads = [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\win.ini"
            ]
            for payload in path_payloads:
                try:
                    response = self.session.get(f"{url}/?file={payload}", timeout=5)
                    for pattern in self.vulnerability_patterns['path_traversal']:
                        if re.search(pattern, response.text, re.I):
                            vulnerabilities.append({
                                'type': 'path_traversal',
                                'url': url,
                                'payload': payload,
                                'severity': 'high',
                                'description': 'Potential path traversal vulnerability detected'
                            })
                            break
                except:
                    continue
            
        except Exception as e:
            console.print(f"[red]Error checking web vulnerabilities: {str(e)}[/]")
        
        return vulnerabilities

    def _check_default_credentials(self, target: str) -> List[Dict]:
        """Check for default credentials."""
        default_creds = {
            'ftp': [('anonymous', 'anonymous')],
            'ssh': [('root', 'root'), ('admin', 'admin')],
            'mysql': [('root', ''), ('admin', 'admin')],
            'postgresql': [('postgres', 'postgres')],
            'tomcat': [('tomcat', 'tomcat'), ('admin', 'admin')]
        }
        
        results = []
        
        for service, credentials in default_creds.items():
            if service == 'ftp':
                try:
                    import ftplib
                    ftp = ftplib.FTP(target)
                    for username, password in credentials:
                        try:
                            ftp.login(username, password)
                            results.append({
                                'service': 'ftp',
                                'username': username,
                                'password': password,
                                'status': 'success'
                            })
                            break
                        except:
                            continue
                except:
                    pass
            
            elif service == 'ssh':
                try:
                    import paramiko
                    for username, password in credentials:
                        try:
                            ssh = paramiko.SSHClient()
                            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
                            ssh.connect(target, username=username, password=password, timeout=5)
                            results.append({
                                'service': 'ssh',
                                'username': username,
                                'password': password,
                                'status': 'success'
                            })
                            break
                        except:
                            continue
                except:
                    pass
        
        return results

    def _detect_technologies(self, html: str) -> List[str]:
        """Detect technologies used in web application."""
        technologies = []
        
        # Common technology signatures
        tech_patterns = {
            'PHP': r'\.php|X-Powered-By: PHP',
            'ASP.NET': r'\.aspx|X-AspNet-Version',
            'Java': r'\.jsp|X-Powered-By: Java',
            'Python': r'\.py|X-Powered-By: Python',
            'Ruby': r'\.rb|X-Powered-By: Ruby',
            'WordPress': r'wp-content|wp-includes',
            'Drupal': r'drupal|Drupal.settings',
            'Joomla': r'joomla|com_content',
            'jQuery': r'jquery\.js',
            'Bootstrap': r'bootstrap\.css|bootstrap\.js',
            'Angular': r'angular\.js|ng-',
            'React': r'react\.js|react-dom',
            'Vue': r'vue\.js|v-'
        }
        
        for tech, pattern in tech_patterns.items():
            if re.search(pattern, html, re.I):
                technologies.append(tech)
        
        return technologies

    def display_scan_results(self, results: Dict) -> None:
        """Display vulnerability scan results."""
        table = Table(title="Vulnerability Scan Results")
        table.add_column("Category", style="cyan")
        table.add_column("Details", style="green")
        
        for key, value in results.items():
            if isinstance(value, (dict, list)):
                value = json.dumps(value, indent=2)
            table.add_row(str(key), str(value))
        
        console.print(table) 